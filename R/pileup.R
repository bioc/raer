#' Generate base counts using pileup
#'
#' @details Multiple bam files can be processed together, with files being
#' written for each bam file. In this mode the output regions will be consistent across all files.
#' The min_mapq and library_type parameters can be specified for each input files.
#'
#' @param bamfiles paths to 1 or more bam files
#' @param fafile path to fasta file
#' @param bedfile path to bed file with sites or regions to query
#' @param region samtools region query string (i.e. chr1:100-1000)
#' @param chroms chromosomes to process, not to be used with region
#' @param min_reads min read depth needed to report site
#' @param min_base_qual min base quality score to consider read for pileup
#' @param min_mapq minimum required MAPQ score
#' @param max_depth maximum read depth considered at each site
#' @param library_type read orientation, one of fr-first-strand,
#' fr-second-strand, or unstranded. Can supply as a vector to specify for each
#' input bam.
#' @param outfile_prefix output prefix for tabix indexed files
#' @param bedidx A BedFile object, if supplied, pileup will use index
#' generated by [indexBed()]
#' @param bam_flags bam flags to filter or keep, use [Rsamtools::scanBamFlag()]
#'  to set
#' @param event_filters integer vector of length 4 with values indicating
#'  distance from pileup position to features to filter. Distance to trim from
#'  5' ends of reads, from 3' end of reads, distance from splicing events, distance from indels, and
#'  length of homopolymer stretch used to determine if a site is in a homopolymer.
#'  The number of read mismatch types (e.g. A->G or G->T) allowed in a single read,
#'  and the required # of any mismatches that activate the mismatch type filter.
#'  default is no filters applied (e.g. c(0,0,0,0,0,0,0)).
#' @param only_keep_variants if TRUE, then only variant sites will be reported
#' (FALSE by default)
#' @param reads if supplied a fasta file will be written with reads that pass filters
#'  and contain variants
#' @param return_data return data as a Granges table?
#' @param BPPARAM A [BiocParallel] class to control parallel execution. Parallel
#' processing occurs per chromosome, so is disabled when run on a single region.
#' @param verbose if TRUE, then report progress.
#'
#' @returns A list containing a `GRanges` object for each input bam file, or a vector
#' of the output tabixed file names if `return_data` is FALSE.
#'
#' @examples
#' bamfn <- system.file("extdata", "SRR5564269_Aligned.sortedByCoord.out.md.bam", package = "raer")
#' bam2fn <- system.file("extdata", "SRR5564277_Aligned.sortedByCoord.out.md.bam", package = "raer")
#' fafn <- system.file("extdata", "human.fasta", package = "raer")
#'
#' plp <- get_pileup(bamfn, fafn)
#' plps <- get_pileup(c(bamfn, bam2fn), fafn)
#'
#' @importFrom Rsamtools bgzip indexTabix TabixFile scanTabix
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#' @importFrom data.table fread
#' @importFrom BiocParallel SerialParam bpstop bplapply ipcid ipclock ipcunlock
#' @export
get_pileup <- function(bamfiles,
                   fafile,
                   bedfile = NULL,
                   region = NULL,
                   chroms = NULL,
                   min_reads = 1L,
                   min_base_qual = 20L,
                   min_mapq = c(0L),
                   max_depth = 1e4,
                   library_type = "fr-first-strand",
                   outfile_prefix = NULL,
                   bedidx = NULL,
                   bam_flags = NULL,
                   event_filters = c(0,0,0,0,0,0,0),
                   only_keep_variants = FALSE,
                   reads = NULL,
                   return_data = TRUE,
                   BPPARAM = SerialParam(),
                   verbose = FALSE){

  bamfiles <- path.expand(bamfiles)
  fafile <- path.expand(fafile)
  n_files <- length(bamfiles)

  if(!is.null(bedfile)){
    bedfile <- path.expand(bedfile)
    if(!file.exists(bedfile)){
      stop("bedfile not found: ", bedfile, call. = FALSE)
    }
  }

  if(!all(file.exists(bamfiles))){
    stop("bamfile(s) not found: ", bamfiles[!file.exists(bamfiles)], call. = FALSE)
  }

  if(!file.exists(fafile)){
    stop("fasta file not found: ", fafile, call. = FALSE)
  }

  using_temp_files <- FALSE
  if(is.null(outfile_prefix)){
    using_temp_files <- TRUE
    outfiles <- unlist(lapply(seq_len(n_files), function(x) tempfile()))
  } else {
    outfiles <- paste0(outfile_prefix, "_", seq_len(n_files), ".plp")
    if(!dir.exists(dirname(outfile_prefix))){
      dir.create(dirname(outfile_prefix), recursive = TRUE)
    }
    outfiles <- unlist(lapply(outfiles, function(x) path.expand(x)))
    unlink(outfiles)
  }

  if(length(outfiles) != n_files){
    stop("# of outfiles does not match # of bam input files: ", outfiles)
  }

  contig_info <- Rsamtools::scanBamHeader(bamfiles[1])[[1]]$targets
  chroms_to_process <- names(contig_info)
  if(is.null(region)) {
    if(!is.null(chroms)){
      if(length(chroms) == 1){
        region <- chroms
        chroms_to_process <- chroms
      } else {
      # not sure how to catch NULL in rcpp so using "." to indicate no region instead
      region = "."
      chroms_to_process <- chroms
      }
    } else {
      region <- "."
    }
  } else {
    chroms_to_process <- get_region(region)$chrom
  }

  missing_chroms <- chroms_to_process[!chroms_to_process %in% names(contig_info)]

  if(length(missing_chroms) > 0){
    warning("the following chromosomes are not present in the bamfile(s):\n",
            paste(missing_chroms, collapse = "\n"),
            call. = FALSE)
    chroms_to_process <- setdiff(chroms_to_process, missing_chroms)
  }

  chroms_to_process <-
       chroms_to_process[order(match(chroms_to_process, names(contig_info)))]

  if(length(chroms_to_process) == 0){
    stop("No chromosomes requested are found in bam file",
         call. = FALSE)
  }

  idx_ptr <- NULL
  if(!is.null(bedidx)){
    if(!is(bedidx, "BedFile") & !(bedidx$open)){
      warning("bedidx not valid, setting to NULL")
      idx_ptr <- NULL
    }

    if(is_null_extptr(bedidx$.extptr)){
      warning("bedidx pointer not valid, setting to NULL")
      idx_ptr <- NULL
    } else {
      idx_ptr <- bedidx$.extptr
    }
    bedfile <- "."
  }

  if(length(event_filters) != 7 || !is.numeric(event_filters)){
    stop("event_filters must be vector of 7 numeric values")
  }

  if(is.null(bam_flags)){
    bam_flags <- Rsamtools::scanBamFlag(isSecondaryAlignment = FALSE,
                                        isNotPassingQualityCont = FALSE,
                                        isDuplicate = FALSE,
                                        isSupplementaryAlignment = FALSE)
  } else {
    if(length(bam_flags) != 2 || !all(names(bam_flags) == c("keep0", "keep1"))){
      stop("bam_flags must be generated using Rsamtools::scanBamFlag")
    }
  }

  # encode libtype as 0 = unstranded, 1 = fr-first-strand, 2 = fr-second-strand
  lib_values <- c("unstranded", "fr-first-strand", "fr-second-strand")
  lib_code <- match(library_type, lib_values)
  if(any(is.na(lib_code))){
    stop("library_type must be one of :", paste(lib_values, collapse = " "))
  } else{
    lib_code <- lib_code - 1
  }

  if(length(lib_code) != n_files){
    lib_code <- rep(lib_code, n_files)
  }

  if(!is.null(reads)){
    if(!is.character(reads) | length(reads) != 1){
      stop("reads must be a character vector of length 1")
    }
  } else {
    reads <- "."
  }

  if(!is.logical(only_keep_variants)){
    stop("only_keep_variants must be a logical value")
  } else {
    only_keep_variants = as.integer(only_keep_variants)
  }

  run_in_parallel <- FALSE
  temp_bed_file <- FALSE
  if(is(BPPARAM, "SerialParam") || length(chroms_to_process) == 1){
    if(length(chroms_to_process) > 1 && is.null(bedfile)){
      temp_bed_file <- TRUE
      bedfile <- tempfile(fileext = ".bed")
      to_process <- contig_info[chroms_to_process]
      bed_gr <- GRanges(paste0(names(to_process), ":", 1, "-", to_process))
      rtracklayer::export(bed_gr, bedfile)
    }

    res <- run_pileup(bampaths = bamfiles,
                      fapath = fafile,
                      region = region,
                      bedfn = ifelse(is.null(bedfile), ".", bedfile),
                      min_reads = min_reads,
                      event_filters = event_filters,
                      min_mapQ = min_mapq,
                      max_depth = max_depth,
                      min_baseQ = min_base_qual,
                      libtype =  as.integer(lib_code),
                      outfns = outfiles,
                      bam_flags = bam_flags,
                      only_keep_variants,
                      reads,
                      idx_ptr)
    if(res == 1){
      stop("Error occured during pileup", call. = FALSE)
    }
    if(temp_bed_file) unlink(bedfile)
  } else {

    run_in_parallel <- TRUE
    res <- bplapply(chroms_to_process, FUN = function(ctig) {
      start_time <- Sys.time()
      tmp_outfiles <- unlist(lapply(seq_along(outfiles), function(x) tempfile()))
      fn_df <- data.frame(contig = ctig,
                          bam_fn = bamfiles,
                          tmpfn = tmp_outfiles)

      ret <- run_pileup(bampaths = bamfiles,
                        fapath = fafile,
                        region = ctig,
                        bedfn = ifelse(is.null(bedfile), ".", bedfile),
                        min_reads = min_reads,
                        event_filters = event_filters,
                        min_mapQ = min_mapq,
                        max_depth = max_depth,
                        min_baseQ = min_base_qual,
                        libtype =  as.integer(lib_code),
                        outfns = tmp_outfiles,
                        bam_flags = bam_flags,
                        only_keep_variants,
                        reads,
                        idx_ptr)
      if(ret == 1){
        stop("Error occured during pileup", call. = FALSE)
      }
      if(verbose){
        time_elapsed <- Sys.time() - start_time
        message("Completed pileup on ", ctig, " in ", time_elapsed)
      }

      fn_df

    },
    BPPARAM=BPPARAM)
    bpstop(BPPARAM)

    tmp_fns <- do.call(rbind, res)
    tmp_fns <- split(tmp_fns, tmp_fns$bam_fn)
    stopifnot(length(tmp_fns) == length(outfiles))

    for(i in seq_along(tmp_fns)){
      fns <- tmp_fns[[i]]$tmpfn
      final_file <- outfiles[i]
      fw <- file.append(final_file, fns)
      if(!all(fw)){
        stop("error occured writing pileup files")
      }
      unlink(fns)
    }
  }

  if(any(file.info(outfiles)$size == 0)){
    return(empty_plp_record())
  }

  # run_pileup writes to a (temp)file, next the file will be tabix indexed
  tbxfiles <- lapply(outfiles, function(x){
    tbxfile <- Rsamtools::bgzip(x, overwrite = TRUE)
    idx <- Rsamtools::indexTabix(tbxfile, seq = 1, start = 2, end = 2, zeroBased = FALSE)
    tbxfile
  })

  if(!return_data){
    unlink(outfiles)
    return(unlist(tbxfiles))
  }

  if(length(tbxfiles) == 1){
    res <- read_pileup(tbxfiles[[1]], region = NULL)
  } else {
    res <- lapply(tbxfiles, function(x) read_pileup(x, region = NULL))
  }

  if(using_temp_files){
    unlink(tbxfiles)
    unlink(paste0(tbxfiles, ".tbi"))
  }
  unlink(outfiles)

  res
}

MAX_INT <- 536870912
#' Read pileup, indexed by tabix
#' @param tbx_fn filename
#' @param region region to read from file, samtools style
#' region specifiers are supported.
#'
#' @examples
#' bamfn <- system.file("extdata", "SRR5564269_Aligned.sortedByCoord.out.md.bam", package = "raer")
#' fafn <- system.file("extdata", "human.fasta", package = "raer")
#'
#' plp <- get_pileup(bamfn, fafn, return_data = FALSE)
#' read_pileup(plp)
#'
#' @export
read_pileup <- function(tbx_fn, region = NULL){

  tbx <- Rsamtools::TabixFile(tbx_fn)

  # using Rsamtools read in tabix file
  # note that file is read in as a list of character vectors
  # consider using our own read_tabix function if this is a bottleneck
  if(!is.null(region)){
    ivl_vals <- get_region(region)
    # note that samtools will return a larger INT than IRANGES can handle
    # if no ranges are supplied in the region
    ivl_end <- min(MAX_INT, ivl_vals$end)
    params <- GenomicRanges::GRanges(ivl_vals$chrom,
                                    IRanges::IRanges(start = ivl_vals$start + 1,
                                                     end = ivl_end))
    tbx_vals <- Rsamtools::scanTabix(tbx, param = params)[[1]]
  } else {
    tbx_vals <- Rsamtools::scanTabix(tbx)[[1]]
  }

  # quick method to convert vector of character strings into data.frame
  if(length(tbx_vals) == 1){
    # handle length 1 character vectors, which will not work with fread
    from = data.frame(t(strsplit(tbx_vals, "\t")[[1]]))
    colnames(from) <- paste0("V", 1:ncol(from))
    from[c(2, 6:12)] <- as.numeric(from[c(2, 6:12)])
  } else {
    from <- data.table::fread(text = tbx_vals,
                              stringsAsFactors = FALSE,
                              data.table = FALSE,
                              showProgress = FALSE,
                              sep="\t")
  }

  count_cols <- c("nRef", "nVar", "nA", "nT", "nC", "nG", "nN")

  colnames(from)[4:ncol(from)] = c("Ref", "Var", count_cols)

  GenomicRanges::GRanges(seqnames=from$V1,
                         ranges=IRanges::IRanges(start=from$V2,
                                                 end=from$V2),
                         strand=from$V3,
                         from[,4:ncol(from)])
}



# generate empty pileup record
# idea from @user2462304 https://stackoverflow.com/a/48180979/6276041
empty_plp_record <-  function(){
  col_types <- list(Ref = character(),
                                 Var = character(),
                                 nRef = integer(),
                                 nVar = integer(),
                                 nA = integer(),
                                 nT = integer(),
                                 nC = integer(),
                                 nG = integer(),
                                 nN = integer())
  df <- do.call(data.frame,col_types)
  gr <- GRanges(c(seqnames=NULL,ranges=NULL,strand=NULL))
  mcols(gr) <- df
  gr
}



#' Generate base counts using pileup
#'
#' @details To compare RNA-seq to DNA-seq 2 bam files can be supplied to the `bamfile`
#' argument, with the first corresponding to RNA-seq and second DNA-seq. The `min_reads`
#'  and `min_mapq` arguments can accept 2 values (as numeric vector) corresponding to filters
#' for RNA and DNA-seq respectively. The `min_base_qual`, `n_align`,
#'  `n_align_tag`, and `event_filters` params will be applied to both files.
#'
#' The library type argument will only apply to the 1st bam file. The second will be set to
#' "unstranded"
#'
#' @param bamfile paths to 1 or 2 bam files, pass 2 files to
#' @param fafile path to fasta file
#' @param bedfile path to bed file with sites or regions to query
#' @param region samtools region query string (i.e. chr1:100-1000)
#' @param chrom chrom to process, not to be used with region
#' @param start start position, not to be used with region
#' @param end end position, not to be used with region
#' @param min_reads min read depth needed to report site
#' @param min_base_qual min base quality score to consider read for pileup
#' @param min_mapq minimum required MAPQ score
#' @param max_depth maximum read depth considered at each site
#' @param library_type read orientation, one of fr-first-strand,
#' fr-second-strand, or unstranded.
#' @param outfile output tabix indexed file?
#' @param bedidx A BedFile object, if supplied, pileup will use index
#' generated by [indexBed()]
#' @param bam_flags bam flags to filter or keep, use [Rsamtools::scanBamFlag()]
#'  to set
#' @param n_align # of valid alignments to use for each read, based on tag value
#' supplied to n_align_tag. NULL disables filtering by n_align_tag
#' value
#' @param n_align_tag Tag name that containing # of valid alignments
#' @param event_filters integer vector of length 4 with values indicating
#'  distance from pileup position to features to filter. Distance to trim from
#'  5' ends of reads, from 3' end of reads, distance from splicing events, distance from indels, and
#'  length of homopolymer stretch used to determine if a site is in a homopolymer.
#'  # of read mismatch types (e.g. A->G or G->T) allowed in a single read,
#'  and the required # of any mismatches that activate the mismatch type filter.
#'  default is no filters applied (e.g. c(0,0,0,0,0,0,0)).
#' @param only_keep_variants if TRUE, then only variant sites will be reported
#' (FALSE by default)
#' @param reads if supplied a fasta file will be written with reads that pass filters
#'  and contain variants
#' @param return_data return data as a Granges table?
#'
#' @importFrom Rsamtools bgzip indexTabix TabixFile scanTabix
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#' @importFrom data.table fread
#' @export
get_pileup <- function(bamfile,
                   fafile,
                   bedfile = NULL,
                   region = NULL,
                   chrom = NULL,
                   start = NULL,
                   end = NULL,
                   min_reads = c(1L),
                   min_base_qual = 20L,
                   min_mapq = c(0L),
                   max_depth = 1e4,
                   library_type = "fr-first-strand",
                   outfile = NULL,
                   bedidx = NULL,
                   bam_flags = NULL,
                   n_align = 0,
                   n_align_tag = "NH",
                   event_filters = c(0,0,0,0,0,0,0),
                   only_keep_variants = FALSE,
                   reads = NULL,
                   return_data = TRUE){

  bamfile <- path.expand(bamfile)
  fafile <- path.expand(fafile)
  n_files <- length(bamfile)

  if(!is.null(bedfile)){
    bedfile <- path.expand(bedfile)
    if(!file.exists(bedfile)){
      stop("bedfile not found: ", bedfile, call. = FALSE)
    }
  } else {
    bedfile = "."
  }

  if(!all(file.exists(bamfile))){
    stop("bamfile not found: ", bamfile[!file.exists(bamfile)], call. = FALSE)
  }

  if(!file.exists(fafile)){
    stop("fasta file not found: ", fafile, call. = FALSE)
  }

  if(is.null(outfile)){
    outfile <- tempfile()
  } else {
    outfile <- path.expand(outfile)
  }
  if(is.null(region)) {
    if(!is.null(chrom)){
      region = chrom
      if(!is.null(start) & !is.null(end)){
        region = paste0(region, ":", start, end)
      }

    } else {
      # not sure how to catch NULL in rcpp so using "." to indicate no region instead
      region = "."
    }
  }

  idx_ptr <- NULL
  if(!is.null(bedidx)){
    if(!is(bedidx, "BedFile") & !(bedidx$open)){
      warning("bedidx not valid, setting to NULL")
      idx_ptr <- NULL
    }

    if(is_null_extptr(bedidx$.extptr)){
      warning("bedidx pointer not valid, setting to NULL")
      idx_ptr <- NULL
    } else {
      idx_ptr <- bedidx$.extptr
    }

    bedfn <- "."
  }

  if(length(event_filters) != 7 || !is.numeric(event_filters)){
    stop("event_filters must be vector of 7 numeric values")
  }

  if(is.null(bam_flags)){
    bam_flags <- Rsamtools::scanBamFlag(isSecondaryAlignment = FALSE,
                                        isNotPassingQualityCont = FALSE,
                                        isDuplicate = FALSE,
                                        isSupplementaryAlignment = FALSE)
  } else {
    if(length(bam_flags) != 2 || !all(names(bam_flags) == c("keep0", "keep1"))){
      stop("bam_flags must be generated using Rsamtools::scanBamFlag")
    }
  }

  if(n_files > 2){
    stop("only 1 or 2 bamfiles can be processed at once")
  }

  # encode libtype as 0 = unstranded, 1 = fr-first-strand, 2 = fr-second-strand
  lib_values <- c("unstranded", "fr-first-strand", "fr-second-strand")
  lib_code <- match(library_type, lib_values)
  if(any(is.na(lib_code))){
    sstop("library_type must be one of :", paste(lib_values, collapse = " "))
  } else{
    lib_code <- lib_code - 1
  }

  if(n_files == 2 && length(lib_code) == 1){
    lib_code <- c(lib_code, 0)
  }

  if(!is.null(reads)){
    if(!is.character(reads) | length(reads) != 1){
      stop("reads must be a character vector of length 1")
    }
  } else {
    reads <- "."
  }

  if(!is.logical(only_keep_variants)){
    stop("only_keep_variants must be a logical value")
  } else {
    only_keep_variants = as.integer(only_keep_variants)
  }

  res <- run_pileup(bampaths = bamfile,
                    fapath = fafile,
                    region = region,
                    outfn = outfile,
                    bedfn = bedfile,
                    min_reads = min_reads,
                    event_filters = event_filters,
                    min_mapQ = min_mapq,
                    max_depth = max_depth,
                    min_baseQ = min_base_qual,
                    libtype =  as.integer(lib_code),
                    bam_flags = bam_flags,
                    n_align = as.integer(n_align),
                    n_align_tag = n_align_tag,
                    only_keep_variants,
                    reads,
                    idx_ptr)

  if(res == 1){
    stop("Error occured during pileup", call. = FALSE)
  }
  if(file.info(outfile)$size == 0){
    return()
  }


  # run_pileup writes to a (temp)file, next the file will be tabix indexed
  tbxfile <- Rsamtools::bgzip(outfile, overwrite = TRUE)
  idx <- Rsamtools::indexTabix(tbxfile, seq = 1, start = 2, end = 2, zeroBased = FALSE)
  tbx <- Rsamtools::TabixFile(tbxfile, idx)

  # using Rsamtools read in tabix file
  # note that file is read in as a character vector
  # consider using our own read_tabix function if this is a bottleneck
  # (https://github.com/kriemo/kentr/blob/master/src/tabix_reader.cpp)
  if(region != "."){
    ivl_vals <- get_region(region)
    params = GenomicRanges::GRanges(ivl_vals$chrom,
                                    IRanges::IRanges(start = ivl_vals$start + 1,
                                                     end = min(ivl_vals$end, MAX_INT)))
    tbx_vals <- Rsamtools::scanTabix(tbx, param = params)[[1]]
  } else {
    tbx_vals <- Rsamtools::scanTabix(tbx)[[1]]
  }

  # quick method to convert vector of character strings into data.frame
  if(length(tbx_vals) == 1){
    # handle length 1 character vectors, which will not work with fread
    from = data.frame(t(strsplit(tbx_vals, "\t")[[1]]))
    colnames(from) <- paste0("V", 1:ncol(from))
    from[c(2, 6:12)] <- as.numeric(from[c(2, 6:12)])
  } else {
    from <- data.table::fread(text = tbx_vals,
                              stringsAsFactors = FALSE,
                              data.table = FALSE,
                              sep="\t")
  }

  count_cols <- c("nRef", "nVar", "nA", "nT", "nC", "nG", "nN")
  if(length(bamfile) == 2){
    count_cols <- paste0(rep(count_cols, 2), rep(c("_1", "_2"), each = length(count_cols)))
  }
  colnames(from)[4:ncol(from)] = c("Ref", "Var", count_cols)
  if(return_data){
    GenomicRanges::GRanges(seqnames=from$V1,
                           ranges=IRanges::IRanges(start=from$V2,
                                                   end=from$V2),
                           strand=from$V3,
                           from[,4:ncol(from)])
  }
}

####################### Utils

MAX_INT <- 536870912

